// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicAuthScopes = "BasicAuth.Scopes"
)

// Defines values for Action.
const (
	ALLOW    Action = "allow"
	DENY     Action = "deny"
	EMAILTFA Action = "emailTfa"
	RSATFA   Action = "rsaTfa"
	SMSTFA   Action = "smsTfa"
	TFA      Action = "tfa"
	WEBTFA   Action = "webTfa"
)

// Defines values for ActionType.
const (
	Skip ActionType = "skip"
)

// Defines values for AuthenticationSchemaConcurrentAccess.
const (
	AuthenticationSchemaConcurrentAccessAllow AuthenticationSchemaConcurrentAccess = "allow"
	AuthenticationSchemaConcurrentAccessError AuthenticationSchemaConcurrentAccess = "error"
	AuthenticationSchemaConcurrentAccessWarn  AuthenticationSchemaConcurrentAccess = "warn"
)

// Defines values for AuthenticationSchemaFallbackSubjectNameIdentifier.
const (
	AuthenticationSchemaFallbackSubjectNameIdentifierDISPLAYNAME     AuthenticationSchemaFallbackSubjectNameIdentifier = "displayName"
	AuthenticationSchemaFallbackSubjectNameIdentifierLOGINNAME       AuthenticationSchemaFallbackSubjectNameIdentifier = "loginName"
	AuthenticationSchemaFallbackSubjectNameIdentifierMAIL            AuthenticationSchemaFallbackSubjectNameIdentifier = "mail"
	AuthenticationSchemaFallbackSubjectNameIdentifierNONE            AuthenticationSchemaFallbackSubjectNameIdentifier = "none"
	AuthenticationSchemaFallbackSubjectNameIdentifierPERSONNELNUMBER AuthenticationSchemaFallbackSubjectNameIdentifier = "personnelNumber"
	AuthenticationSchemaFallbackSubjectNameIdentifierUID             AuthenticationSchemaFallbackSubjectNameIdentifier = "uid"
	AuthenticationSchemaFallbackSubjectNameIdentifierUSERUUID        AuthenticationSchemaFallbackSubjectNameIdentifier = "userUuid"
)

// Defines values for AuthenticationSchemaRememberMeExpirationTimeInMonths.
const (
	N1  AuthenticationSchemaRememberMeExpirationTimeInMonths = 1
	N12 AuthenticationSchemaRememberMeExpirationTimeInMonths = 12
	N24 AuthenticationSchemaRememberMeExpirationTimeInMonths = 24
	N3  AuthenticationSchemaRememberMeExpirationTimeInMonths = 3
	N36 AuthenticationSchemaRememberMeExpirationTimeInMonths = 36
	N6  AuthenticationSchemaRememberMeExpirationTimeInMonths = 6
)

// Defines values for AuthenticationSchemaSsoType.
const (
	OpenIdConnect AuthenticationSchemaSsoType = "openIdConnect"
	Saml2         AuthenticationSchemaSsoType = "saml2"
)

// Defines values for AuthenticationSchemaSubjectNameIdentifierFunction.
const (
	LowerCase AuthenticationSchemaSubjectNameIdentifierFunction = "lowerCase"
	None      AuthenticationSchemaSubjectNameIdentifierFunction = "none"
	UpperCase AuthenticationSchemaSubjectNameIdentifierFunction = "upperCase"
)

// Defines values for AuthorizationScope.
const (
	MAANGEAPP   AuthorizationScope = "manageApp"
	MANAGEUSERS AuthorizationScope = "manageUsers"
	OAUTH       AuthorizationScope = "oAuth"
)

// Defines values for BindingName.
const (
	UrnOasisNamesTcSAML20BindingsHTTPPOST     BindingName = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
	UrnOasisNamesTcSAML20BindingsHTTPRedirect BindingName = "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
	UrnOasisNamesTcSAML20BindingsSOAP         BindingName = "urn:oasis:names:tc:SAML:2.0:bindings:SOAP"
)

// Defines values for BrandingTokenUrlEmbedCharacter.
const (
	FRAGMENT  BrandingTokenUrlEmbedCharacter = "#"
	QUERY     BrandingTokenUrlEmbedCharacter = "?/&"
	SEMICOLON BrandingTokenUrlEmbedCharacter = ";"
)

// Defines values for CredentialType.
const (
	CERT           CredentialType = "cert"
	SOCIALIDENTITY CredentialType = "socialIdentity"
	SPNEGO         CredentialType = "spnego"
	TOKEN          CredentialType = "token"
	UIDPW          CredentialType = "uidPw"
)

// Defines values for GrantType.
const (
	AUTHORIZATIONCODE         GrantType = "authorizationCode"
	AUTHORIZATIONCODEPKCES256 GrantType = "authorizationCodePkceS256"
	CLIENTCREDENTIALS         GrantType = "clientCredentials"
	IMPLICIT                  GrantType = "implicit"
	JWTBEARER                 GrantType = "jwtBearer"
	PASSWORD                  GrantType = "password"
	REFRESHTOKEN              GrantType = "refreshToken"
	TOKENEXCHANGE             GrantType = "tokenExchange"
)

// Defines values for GroupType.
const (
	CLOUD     GroupType = "cloud"
	ONPREMISE GroupType = "onPremise"
)

// Defines values for MetaType.
const (
	Bundled MetaType = "bundled"
	Charged MetaType = "charged"
	System  MetaType = "system"
)

// Defines values for PatchOperationOp.
const (
	Add     PatchOperationOp = "add"
	Remove  PatchOperationOp = "remove"
	Replace PatchOperationOp = "replace"
)

// Defines values for ProxyAuthnRequestAuthenticationContext.
const (
	ProxyAuthnRequestAuthenticationContextFORWARDAPPLICATIONAUTHNCONTEXT ProxyAuthnRequestAuthenticationContext = "forwardApplicationAuthnContext"
	ProxyAuthnRequestAuthenticationContextNONE                           ProxyAuthnRequestAuthenticationContext = "none"
	ProxyAuthnRequestAuthenticationContextPASSWORDPROTECTEDTRANSPORT     ProxyAuthnRequestAuthenticationContext = "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport"
)

// Defines values for SamlConfigurationDefaultNameIdFormat.
const (
	EMAIL       SamlConfigurationDefaultNameIdFormat = "urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress"
	PERSISTENT  SamlConfigurationDefaultNameIdFormat = "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent"
	TRANSIENT   SamlConfigurationDefaultNameIdFormat = "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
	UNSPECIFIED SamlConfigurationDefaultNameIdFormat = "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
)

// Defines values for SamlConfigurationDigestAlgorithm.
const (
	SHA1   SamlConfigurationDigestAlgorithm = "sha1"
	SHA256 SamlConfigurationDigestAlgorithm = "sha256"
	SHA512 SamlConfigurationDigestAlgorithm = "sha512"
)

// Defines values for SamlConfigurationResponseElementsToEncrypt.
const (
	ATTRIBUTES                 SamlConfigurationResponseElementsToEncrypt = "attributes"
	NONE                       SamlConfigurationResponseElementsToEncrypt = "none"
	SUBJECTNAMEID              SamlConfigurationResponseElementsToEncrypt = "subjectNameId"
	SUBJECTNAMEIDANDATTRIBUTES SamlConfigurationResponseElementsToEncrypt = "subjectNameIdAndAttributes"
	WHOLEASSERTION             SamlConfigurationResponseElementsToEncrypt = "wholeAssertion"
)

// Defines values for SapManagedAttributesType.
const (
	IDENTITYINSTANCE SapManagedAttributesType = "identityInstance"
	REUSEINSTANCE    SapManagedAttributesType = "reuseInstance"
	SUBSCRIPTION     SapManagedAttributesType = "subscription"
)

// Defines values for SchemasEnum.
const (
	SchemasEnumUrnSapIdentityApplicationSchemasCore10                       SchemasEnum = "urn:sap:identity:application:schemas:core:1.0"
	SchemasEnumUrnSapIdentityApplicationSchemasExtensionSci10Authentication SchemasEnum = "urn:sap:identity:application:schemas:extension:sci:1.0:Authentication"
	SchemasEnumUrnSapIdentityApplicationSchemasExtensionSci10Authorization  SchemasEnum = "urn:sap:identity:application:schemas:extension:sci:1.0:Authorization"
	SchemasEnumUrnSapIdentityApplicationSchemasExtensionSci10Provisioning   SchemasEnum = "urn:sap:identity:application:schemas:extension:sci:1.0:Provisioning"
)

// Defines values for TokenPolicyRefreshTokenRotationScenario.
const (
	MOBILE TokenPolicyRefreshTokenRotationScenario = "mobile"
	OFF    TokenPolicyRefreshTokenRotationScenario = "off"
	ONLINE TokenPolicyRefreshTokenRotationScenario = "online"
)

// Defines values for UserAccessType.
const (
	UserAccessTypeInternal UserAccessType = "internal"
	UserAccessTypePrivate  UserAccessType = "private"
	UserAccessTypePublic   UserAccessType = "public"
)

// Defines values for UserType.
const (
	UserTypeCustomer  UserType = "customer"
	UserTypeEmployee  UserType = "employee"
	UserTypeExternal  UserType = "external"
	UserTypeOnboardee UserType = "onboardee"
	UserTypePartner   UserType = "partner"
	UserTypePublic    UserType = "public"
)

// Defines values for GetAllApplicationsParamsSchema.
const (
	GetAllApplicationsParamsSchemaUrnSapIdentityApplicationSchemasCore10                       GetAllApplicationsParamsSchema = "urn:sap:identity:application:schemas:core:1.0"
	GetAllApplicationsParamsSchemaUrnSapIdentityApplicationSchemasExtensionSci10Authentication GetAllApplicationsParamsSchema = "urn:sap:identity:application:schemas:extension:sci:1.0:Authentication"
	GetAllApplicationsParamsSchemaUrnSapIdentityApplicationSchemasExtensionSci10Authorization  GetAllApplicationsParamsSchema = "urn:sap:identity:application:schemas:extension:sci:1.0:Authorization"
	GetAllApplicationsParamsSchemaUrnSapIdentityApplicationSchemasExtensionSci10Provisioning   GetAllApplicationsParamsSchema = "urn:sap:identity:application:schemas:extension:sci:1.0:Provisioning"
)

// Defines values for GetApplicationParamsSchema.
const (
	UrnSapIdentityApplicationSchemasCore10                       GetApplicationParamsSchema = "urn:sap:identity:application:schemas:core:1.0"
	UrnSapIdentityApplicationSchemasExtensionSci10Authentication GetApplicationParamsSchema = "urn:sap:identity:application:schemas:extension:sci:1.0:Authentication"
	UrnSapIdentityApplicationSchemasExtensionSci10Authorization  GetApplicationParamsSchema = "urn:sap:identity:application:schemas:extension:sci:1.0:Authorization"
	UrnSapIdentityApplicationSchemasExtensionSci10Provisioning   GetApplicationParamsSchema = "urn:sap:identity:application:schemas:extension:sci:1.0:Provisioning"
)

// Action defines model for Action.
type Action string

// ActionType defines model for ActionType.
type ActionType string

// AdvancedAssertionAttribute defines model for AdvancedAssertionAttribute.
type AdvancedAssertionAttribute struct {
	AttributeName  *string `json:"attributeName,omitempty"`
	AttributeValue *string `json:"attributeValue,omitempty"`
}

// ApiCertificateData defines model for ApiCertificateData.
type ApiCertificateData struct {
	AuthorizationScopes *[]AuthorizationScope `json:"authorizationScopes,omitempty"`
	Base64Certificate   string                `json:"base64Certificate"`
	Description         *string               `json:"description,omitempty"`
	Dn                  *string               `json:"dn,omitempty"`
}

// ApiSecretData defines model for ApiSecretData.
type ApiSecretData struct {
	AuthorizationScopes *[]AuthorizationScope `json:"authorizationScopes,omitempty"`
	Description         *string               `json:"description,omitempty"`
	Hint                *string               `json:"hint,omitempty"`
	ValidTo             *time.Time            `json:"validTo,omitempty"`
}

// ApiSecretResponse defines model for ApiSecretResponse.
type ApiSecretResponse struct {
	AuthorizationScopes *[]AuthorizationScope `json:"authorizationScopes,omitempty"`
	Description         *string               `json:"description,omitempty"`
	Hint                *string               `json:"hint,omitempty"`
	Secret              *string               `json:"secret,omitempty"`
	ValidTo             *time.Time            `json:"validTo,omitempty"`
}

// ApiSecretsResponse defines model for ApiSecretsResponse.
type ApiSecretsResponse struct {
	Secrets *[]ApiSecretData `json:"secrets,omitempty"`
}

// Application defines model for Application.
type Application struct {
	Branding      *Branding           `json:"branding,omitempty"`
	Description   *string             `json:"description,omitempty"`
	GlobalAccount *string             `json:"globalAccount,omitempty"`
	Id            *openapi_types.UUID `json:"id,omitempty"`

	// MultiTenantApp Only for SAP internal use.
	MultiTenantApp                                               *bool                   `json:"multiTenantApp,omitempty"`
	Name                                                         *string                 `json:"name,omitempty"`
	ParentApplicationId                                          *openapi_types.UUID     `json:"parentApplicationId,omitempty"`
	PrivacyPolicy                                                *string                 `json:"privacyPolicy,omitempty"`
	Schemas                                                      *[]SchemasEnum          `json:"schemas,omitempty"`
	TermsOfUse                                                   *string                 `json:"termsOfUse,omitempty"`
	UrnSapIdentityApplicationSchemasExtensionSci10Authentication *AuthenticationSchema   `json:"urn:sap:identity:application:schemas:extension:sci:1.0:Authentication,omitempty"`
	UrnSapIdentityApplicationSchemasExtensionSci10Authorization  *map[string]interface{} `json:"urn:sap:identity:application:schemas:extension:sci:1.0:Authorization,omitempty"`
	UrnSapIdentityApplicationSchemasExtensionSci10Provisioning   *map[string]interface{} `json:"urn:sap:identity:application:schemas:extension:sci:1.0:Provisioning,omitempty"`
}

// ApplicationPatch defines model for ApplicationPatch.
type ApplicationPatch struct {
	Operations []PatchOperation `json:"operations"`
}

// ApplicationResponse defines model for ApplicationResponse.
type ApplicationResponse struct {
	Branding      *Branding           `json:"branding,omitempty"`
	Description   *string             `json:"description,omitempty"`
	GlobalAccount *string             `json:"globalAccount,omitempty"`
	Id            *openapi_types.UUID `json:"id,omitempty"`
	Meta          *Meta               `json:"meta,omitempty"`

	// MultiTenantApp Only for SAP internal use.
	MultiTenantApp                                               *bool                   `json:"multiTenantApp,omitempty"`
	Name                                                         *string                 `json:"name,omitempty"`
	ParentApplicationId                                          *openapi_types.UUID     `json:"parentApplicationId,omitempty"`
	PrivacyPolicy                                                *string                 `json:"privacyPolicy,omitempty"`
	Schemas                                                      *[]SchemasEnum          `json:"schemas,omitempty"`
	TermsOfUse                                                   *string                 `json:"termsOfUse,omitempty"`
	UrnSapIdentityApplicationSchemasExtensionSci10Authentication *AuthenticationSchema   `json:"urn:sap:identity:application:schemas:extension:sci:1.0:Authentication,omitempty"`
	UrnSapIdentityApplicationSchemasExtensionSci10Authorization  *map[string]interface{} `json:"urn:sap:identity:application:schemas:extension:sci:1.0:Authorization,omitempty"`
	UrnSapIdentityApplicationSchemasExtensionSci10Provisioning   *map[string]interface{} `json:"urn:sap:identity:application:schemas:extension:sci:1.0:Provisioning,omitempty"`
}

// ApplicationsResponse defines model for ApplicationsResponse.
type ApplicationsResponse struct {
	Applications *[]ApplicationResponse `json:"applications,omitempty"`
	ItemsPerPage *int32                 `json:"itemsPerPage,omitempty"`
	NextCursor   *string                `json:"nextCursor,omitempty"`
	TotalResults *int32                 `json:"totalResults,omitempty"`
}

// AssertionAttribute defines model for AssertionAttribute.
type AssertionAttribute struct {
	AssertionAttributeName string `json:"assertionAttributeName"`
	UserAttributeName      string `json:"userAttributeName"`
}

// AuthenticationSchema defines model for Authentication-Schema.
type AuthenticationSchema struct {
	AdvancedAssertionAttributes *[]AdvancedAssertionAttribute `json:"advancedAssertionAttributes,omitempty"`

	// AllowIasUsers Allow users stored in Identity Authentication service to log on.Url: https://tenant.accounts.ondemand.com/saml2/idp/sso?sp=test&idp=https://tenant.accounts.ondemand.com
	AllowIasUsers       *bool                 `json:"allowIasUsers,omitempty"`
	ApiCertificates     *[]ApiCertificateData `json:"apiCertificates,omitempty"`
	AssertionAttributes *[]AssertionAttribute `json:"assertionAttributes,omitempty"`

	// BiometricAuthenticationEnabled Biometric Authentication
	BiometricAuthenticationEnabled *bool          `json:"biometricAuthenticationEnabled,omitempty"`
	CaptchaConfig                  *CaptchaConfig `json:"captchaConfig,omitempty"`

	// ClientId it's the same for clientId in OIDC flows
	ClientId                      *string                                            `json:"clientId,omitempty"`
	CompanyId                     *string                                            `json:"companyId,omitempty"`
	ConcurrentAccess              *AuthenticationSchemaConcurrentAccess              `json:"concurrentAccess,omitempty"`
	ConditionalAuthentication     *[]AuthenticationRule                              `json:"conditionalAuthentication,omitempty"`
	ConsumedApis                  *[]ConsumedApi                                     `json:"consumedApis,omitempty"`
	ConsumedServices              *[]ConsumedService                                 `json:"consumedServices,omitempty"`
	DefaultAuthenticatingIdpId    *string                                            `json:"defaultAuthenticatingIdpId,omitempty"`
	FallbackSubjectNameIdentifier *AuthenticationSchemaFallbackSubjectNameIdentifier `json:"fallbackSubjectNameIdentifier,omitempty"`

	// ForceAuthentication Force authentication with each request. Ignores session cookies.
	ForceAuthentication *bool   `json:"forceAuthentication,omitempty"`
	HomeUrl             *string `json:"homeUrl,omitempty"`

	// IdpCertificateSerialNumber It's used to specify the IDP Certificate used for signature check.
	IdpCertificateSerialNumber       *string                                               `json:"idpCertificateSerialNumber,omitempty"`
	JwtClientAuthCredentials         *[]JwtClientAuthCredential                            `json:"jwtClientAuthCredentials,omitempty"`
	OpenIdConnectConfiguration       *OIDCConfiguration                                    `json:"openIdConnectConfiguration,omitempty"`
	PasswordPolicy                   *string                                               `json:"passwordPolicy,omitempty"`
	ProvidedApis                     *[]ProvidedApi                                        `json:"providedApis,omitempty"`
	RememberMeExpirationTimeInMonths *AuthenticationSchemaRememberMeExpirationTimeInMonths `json:"rememberMeExpirationTimeInMonths,omitempty"`
	RiskBasedAuthentication          *RBAConfiguration                                     `json:"riskBasedAuthentication,omitempty"`
	Saml2Configuration               *SamlConfiguration                                    `json:"saml2Configuration,omitempty"`

	// SapManagedAttributes Only for SAP internal use.
	SapManagedAttributes  *SapManagedAttributes  `json:"sapManagedAttributes,omitempty"`
	SmsVerificationConfig *SmsVerificationConfig `json:"smsVerificationConfig,omitempty"`

	// SocialSignOn Enable authentication with social providers like Google and Twitter.
	SocialSignOn *bool `json:"socialSignOn,omitempty"`

	// SpnegoEnabled SPNEGO Authentication
	SpnegoEnabled                 *bool                                              `json:"spnegoEnabled,omitempty"`
	SsoType                       *AuthenticationSchemaSsoType                       `json:"ssoType,omitempty"`
	SubjectNameIdentifier         *string                                            `json:"subjectNameIdentifier,omitempty"`
	SubjectNameIdentifierFunction *AuthenticationSchemaSubjectNameIdentifierFunction `json:"subjectNameIdentifierFunction,omitempty"`

	// TrustAllCorporateIdentityProviders Allow IdP-initiated logon from all configured corporate identity providers.
	TrustAllCorporateIdentityProviders *bool       `json:"trustAllCorporateIdentityProviders,omitempty"`
	UserAccess                         *UserAccess `json:"userAccess,omitempty"`

	// VerifyMail Require verified user email on login.
	VerifyMail *bool `json:"verifyMail,omitempty"`
}

// AuthenticationSchemaConcurrentAccess defines model for AuthenticationSchema.ConcurrentAccess.
type AuthenticationSchemaConcurrentAccess string

// AuthenticationSchemaFallbackSubjectNameIdentifier defines model for AuthenticationSchema.FallbackSubjectNameIdentifier.
type AuthenticationSchemaFallbackSubjectNameIdentifier string

// AuthenticationSchemaRememberMeExpirationTimeInMonths defines model for AuthenticationSchema.RememberMeExpirationTimeInMonths.
type AuthenticationSchemaRememberMeExpirationTimeInMonths int

// AuthenticationSchemaSsoType defines model for AuthenticationSchema.SsoType.
type AuthenticationSchemaSsoType string

// AuthenticationSchemaSubjectNameIdentifierFunction defines model for AuthenticationSchema.SubjectNameIdentifierFunction.
type AuthenticationSchemaSubjectNameIdentifierFunction string

// AuthenticationRule defines model for AuthenticationRule.
type AuthenticationRule struct {
	IdentityProviderId *string   `json:"identityProviderId,omitempty"`
	IpNetworkRange     *string   `json:"ipNetworkRange,omitempty"`
	UserEmailDomain    *string   `json:"userEmailDomain,omitempty"`
	UserGroup          *string   `json:"userGroup,omitempty"`
	UserType           *UserType `json:"userType,omitempty"`
}

// AuthorizationScope defines model for AuthorizationScope.
type AuthorizationScope string

// BindingName defines model for BindingName.
type BindingName string

// Branding defines model for Branding.
type Branding struct {
	DisplayName                  *string                         `json:"displayName,omitempty"`
	EmailTemplateSet             *string                         `json:"emailTemplateSet,omitempty"`
	RefreshParent                *bool                           `json:"refreshParent,omitempty"`
	RememberMeChecked            *bool                           `json:"rememberMeChecked,omitempty"`
	RememberMeVisible            *bool                           `json:"rememberMeVisible,omitempty"`
	ShowDisplayNameOnLogonScreen *bool                           `json:"showDisplayNameOnLogonScreen,omitempty"`
	Theme                        *Theme                          `json:"theme,omitempty"`
	TokenUrlEmbedCharacter       *BrandingTokenUrlEmbedCharacter `json:"tokenUrlEmbedCharacter,omitempty"`
}

// BrandingTokenUrlEmbedCharacter defines model for Branding.TokenUrlEmbedCharacter.
type BrandingTokenUrlEmbedCharacter string

// CaptchaConfig defines model for CaptchaConfig.
type CaptchaConfig struct {
	ForgotPassword *bool `json:"forgot_password,omitempty"`
	Login          *bool `json:"login,omitempty"`
	Registration   *bool `json:"registration,omitempty"`
}

// ConsumedApi defines model for ConsumedApi.
type ConsumedApi struct {
	ApiName  string             `json:"apiName"`
	AppId    openapi_types.UUID `json:"appId"`
	ClientId *string            `json:"clientId,omitempty"`
	Name     string             `json:"name"`
}

// ConsumedService defines model for ConsumedService.
type ConsumedService struct {
	AppId             openapi_types.UUID `json:"appId"`
	ClientId          string             `json:"clientId"`
	Inherit           bool               `json:"inherit"`
	PlanName          *string            `json:"planName,omitempty"`
	ServiceInstanceId *string            `json:"serviceInstanceId,omitempty"`
}

// CorporateIdpAttribute defines model for CorporateIdpAttribute.
type CorporateIdpAttribute struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// CredentialType defines model for CredentialType.
type CredentialType string

// EncryptionCertificateData defines model for EncryptionCertificateData.
type EncryptionCertificateData struct {
	Base64Certificate string     `json:"base64Certificate"`
	Dn                *string    `json:"dn,omitempty"`
	ValidFrom         *time.Time `json:"validFrom,omitempty"`
	ValidTo           *time.Time `json:"validTo,omitempty"`
}

// Error defines model for Error.
type Error struct {
	Code    int32          `json:"code"`
	Details *[]ErrorDetail `json:"details,omitempty"`
	Message string         `json:"message"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	Message *string `json:"message,omitempty"`
	Target  *string `json:"target,omitempty"`
}

// GrantType defines model for GrantType.
type GrantType string

// GroupType defines model for GroupType.
type GroupType string

// JwtClientAuthCredential defines model for JwtClientAuthCredential.
type JwtClientAuthCredential struct {
	AuthorizationScopes *[]AuthorizationScope `json:"authorizationScopes,omitempty"`
	Description         *string               `json:"description,omitempty"`
	IdentityProviderId  string                `json:"identityProviderId"`
	Subject             string                `json:"subject"`
}

// Meta defines model for Meta.
type Meta struct {
	Created          *time.Time `json:"created,omitempty"`
	CreatedBy        *string    `json:"createdBy,omitempty"`
	LastModified     *time.Time `json:"lastModified,omitempty"`
	Location         *string    `json:"location,omitempty"`
	ModifiedBy       *string    `json:"modifiedBy,omitempty"`
	ModifiedOnBehalf *string    `json:"modifiedOnBehalf,omitempty"`
	Type             *MetaType  `json:"type,omitempty"`
	Version          *string    `json:"version,omitempty"`
}

// MetaType defines model for Meta.Type.
type MetaType string

// OIDCConfiguration defines model for OIDCConfiguration.
type OIDCConfiguration struct {
	AllowPublicClientFlows *bool        `json:"allowPublicClientFlows,omitempty"`
	FrontChannelLogoutUris *[]string    `json:"frontChannelLogoutUris,omitempty"`
	PostLogoutRedirectUris *[]string    `json:"postLogoutRedirectUris,omitempty"`
	RedirectUris           *[]string    `json:"redirectUris,omitempty"`
	RestrictedGrantTypes   *[]GrantType `json:"restrictedGrantTypes,omitempty"`
	TokenPolicy            *TokenPolicy `json:"tokenPolicy,omitempty"`
}

// PatchOperation defines model for PatchOperation.
type PatchOperation struct {
	// Op Indicates the operation to perform.
	Op PatchOperationOp `json:"op"`

	// Path An attribute path describing the target of the operation.
	Path string `json:"path"`

	// Value The payload to be applied on the target of the operation.
	Value *PatchOperationValue `json:"value,omitempty"`
}

// PatchOperationOp Indicates the operation to perform.
type PatchOperationOp string

// PatchOperationValue The payload to be applied on the target of the operation.
type PatchOperationValue = map[string]interface{}

// ProvidedApi defines model for ProvidedApi.
type ProvidedApi struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// ProxyAuthnRequest defines model for ProxyAuthnRequest.
type ProxyAuthnRequest struct {
	AuthenticationContext *ProxyAuthnRequestAuthenticationContext `json:"authenticationContext,omitempty"`
	IssuerNameSuffix      *string                                 `json:"issuerNameSuffix,omitempty"`
}

// ProxyAuthnRequestAuthenticationContext defines model for ProxyAuthnRequest.AuthenticationContext.
type ProxyAuthnRequestAuthenticationContext string

// RBAConfiguration defines model for RBAConfiguration.
type RBAConfiguration struct {
	DefaultAction []Action  `json:"defaultAction"`
	Rules         []RBARule `json:"rules"`
}

// RBARule defines model for RBARule.
type RBARule struct {
	Actions               []Action               `json:"actions"`
	AuthMethod            *CredentialType        `json:"authMethod,omitempty"`
	CorporateIdpAttribute *CorporateIdpAttribute `json:"corporateIdpAttribute,omitempty"`
	Group                 *string                `json:"group,omitempty"`
	GroupType             *GroupType             `json:"groupType,omitempty"`
	IpForwardRange        *string                `json:"ipForwardRange,omitempty"`
	IpNetworkRange        *string                `json:"ipNetworkRange,omitempty"`
	UserType              *UserType              `json:"userType,omitempty"`
}

// SAML2ACSEndpoint defines model for SAML2ACSEndpoint.
type SAML2ACSEndpoint struct {
	BindingName BindingName `json:"bindingName"`
	Index       int         `json:"index"`
	IsDefault   *bool       `json:"isDefault,omitempty"`
	Location    string      `json:"location"`
}

// SAML2SLOEndpoint defines model for SAML2SLOEndpoint.
type SAML2SLOEndpoint struct {
	BindingName      BindingName `json:"bindingName"`
	IsDefault        *bool       `json:"isDefault,omitempty"`
	Location         string      `json:"location"`
	ResponseLocation *string     `json:"responseLocation,omitempty"`
}

// SamlConfiguration defines model for SamlConfiguration.
type SamlConfiguration struct {
	AcsEndpoints              *[]SAML2ACSEndpoint                         `json:"acsEndpoints,omitempty"`
	CertificateForEncryption  *EncryptionCertificateData                  `json:"certificateForEncryption,omitempty"`
	CertificatesForSigning    *[]SigningCertificateData                   `json:"certificatesForSigning,omitempty"`
	DefaultNameIdFormat       *SamlConfigurationDefaultNameIdFormat       `json:"defaultNameIdFormat,omitempty"`
	DigestAlgorithm           *SamlConfigurationDigestAlgorithm           `json:"digestAlgorithm,omitempty"`
	MetadataUrl               *string                                     `json:"metadataUrl,omitempty"`
	ProxyAuthnRequest         *ProxyAuthnRequest                          `json:"proxyAuthnRequest,omitempty"`
	RequireSignedAuthnRequest *bool                                       `json:"requireSignedAuthnRequest,omitempty"`
	RequireSignedSLOMessages  *bool                                       `json:"requireSignedSLOMessages,omitempty"`
	ResponseElementsToEncrypt *SamlConfigurationResponseElementsToEncrypt `json:"responseElementsToEncrypt,omitempty"`
	SignAssertions            *bool                                       `json:"signAssertions,omitempty"`
	SignAuthnResponses        *bool                                       `json:"signAuthnResponses,omitempty"`
	SignSLOMessages           *bool                                       `json:"signSLOMessages,omitempty"`
	SloEndpoints              *[]SAML2SLOEndpoint                         `json:"sloEndpoints,omitempty"`
}

// SamlConfigurationDefaultNameIdFormat defines model for SamlConfiguration.DefaultNameIdFormat.
type SamlConfigurationDefaultNameIdFormat string

// SamlConfigurationDigestAlgorithm defines model for SamlConfiguration.DigestAlgorithm.
type SamlConfigurationDigestAlgorithm string

// SamlConfigurationResponseElementsToEncrypt defines model for SamlConfiguration.ResponseElementsToEncrypt.
type SamlConfigurationResponseElementsToEncrypt string

// SapManagedAttributes Only for SAP internal use.
type SapManagedAttributes struct {
	AppTenantId       *string                   `json:"appTenantId,omitempty"`
	PlanName          *string                   `json:"planName,omitempty"`
	SapZoneId         *string                   `json:"sapZoneId,omitempty"`
	ServiceInstanceId *string                   `json:"serviceInstanceId,omitempty"`
	SourceAppId       *openapi_types.UUID       `json:"sourceAppId,omitempty"`
	SourceTenantId    *string                   `json:"sourceTenantId,omitempty"`
	Type              *SapManagedAttributesType `json:"type,omitempty"`
}

// SapManagedAttributesType defines model for SapManagedAttributes.Type.
type SapManagedAttributesType string

// SchemasEnum defines model for SchemasEnum.
type SchemasEnum string

// SigningCertificateData defines model for SigningCertificateData.
type SigningCertificateData struct {
	Base64Certificate string     `json:"base64Certificate"`
	Dn                *string    `json:"dn,omitempty"`
	IsDefault         bool       `json:"isDefault"`
	ValidFrom         *time.Time `json:"validFrom,omitempty"`
	ValidTo           *time.Time `json:"validTo,omitempty"`
}

// SmsVerificationConfig defines model for SmsVerificationConfig.
type SmsVerificationConfig struct {
	IsVerificationRequired *bool               `json:"isVerificationRequired,omitempty"`
	VerificationRules      *[]VerificationRule `json:"verificationRules,omitempty"`
}

// Theme defines model for Theme.
type Theme struct {
	Advanced *string            `json:"advanced,omitempty"`
	Basic    *map[string]string `json:"basic,omitempty"`
	Name     *string            `json:"name,omitempty"`
}

// TokenPolicy defines model for TokenPolicy.
type TokenPolicy struct {
	JwtValidity                  *int                                     `json:"jwtValidity,omitempty"`
	RefreshParallel              *int                                     `json:"refreshParallel,omitempty"`
	RefreshTokenRotationScenario *TokenPolicyRefreshTokenRotationScenario `json:"refreshTokenRotationScenario,omitempty"`
	RefreshValidity              *int                                     `json:"refreshValidity,omitempty"`
}

// TokenPolicyRefreshTokenRotationScenario defines model for TokenPolicy.RefreshTokenRotationScenario.
type TokenPolicyRefreshTokenRotationScenario string

// UserAccess defines model for UserAccess.
type UserAccess struct {
	Type                    *UserAccessType  `json:"type,omitempty"`
	UserAttributesForAccess *[]UserAttribute `json:"userAttributesForAccess,omitempty"`
}

// UserAccessType defines model for UserAccess.Type.
type UserAccessType string

// UserAttribute defines model for UserAttribute.
type UserAttribute struct {
	IsRequired        *bool  `json:"isRequired,omitempty"`
	UserAttributeName string `json:"userAttributeName"`
}

// UserType defines model for UserType.
type UserType string

// VerificationRule defines model for VerificationRule.
type VerificationRule struct {
	Action         *ActionType        `json:"action,omitempty"`
	UserAttributes *map[string]string `json:"userAttributes,omitempty"`
}

// GetAllApplicationsParams defines parameters for GetAllApplications.
type GetAllApplicationsParams struct {
	// Schema Specifies the schemas that should be returned in the response.
	Schema *GetAllApplicationsParamsSchema `form:"schema,omitempty" json:"schema,omitempty"`

	// Filter Defines the search criteria.
	// Supported operators:
	// | Operator | Behavior |
	// |---- | ------------- |
	// | eq | The attribute and operator values must be identical for a match.|
	// ### Supported Attributes:
	// #### Core Schema
	//   * id
	//   * parentApplicationId
	//   * name
	//
	// ### Authentication Schema
	//   * clientId
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit Number of items to return.
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty"`

	// Skip Number of items to skip.
	Skip *int32 `form:"skip,omitempty" json:"skip,omitempty"`

	// Cursor Cursor to the starting identifier in a page.
	Cursor *openapi_types.UUID `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Inherit Specifies whether the application will have inherited properties from the parent or source application
	Inherit *bool `form:"inherit,omitempty" json:"inherit,omitempty"`
}

// GetAllApplicationsParamsSchema defines parameters for GetAllApplications.
type GetAllApplicationsParamsSchema string

// CreateApplicationParams defines parameters for CreateApplication.
type CreateApplicationParams struct {
	// ModifiedOnBehalfOf Provides the entity that should be used in a modified on behalf scenario.
	ModifiedOnBehalfOf *string `json:"Modified-on-behalf-of,omitempty"`
}

// GetApplicationParams defines parameters for GetApplication.
type GetApplicationParams struct {
	// Schema Specifies the schemas that should be returned in the response.
	Schema *GetApplicationParamsSchema `form:"schema,omitempty" json:"schema,omitempty"`

	// Inherit Specifies whether the application will have inherited properties from the parent or source application
	Inherit *bool `form:"inherit,omitempty" json:"inherit,omitempty"`
}

// GetApplicationParamsSchema defines parameters for GetApplication.
type GetApplicationParamsSchema string

// PatchApplicationParams defines parameters for PatchApplication.
type PatchApplicationParams struct {
	// ModifiedOnBehalfOf Provides the entity that should be considered in a modified on behalf scenario.
	ModifiedOnBehalfOf *string `json:"Modified-on-behalf-of,omitempty"`
}

// UpdateApplicationParams defines parameters for UpdateApplication.
type UpdateApplicationParams struct {
	// ModifiedOnBehalfOf Provides the entity that should be considered in a modified on behalf scenario.
	ModifiedOnBehalfOf *string `json:"Modified-on-behalf-of,omitempty"`
}

// DeleteApiSecretParams defines parameters for DeleteApiSecret.
type DeleteApiSecretParams struct {
	// Hint This is the hint to identify the exact secret to be deleted.
	Hint string `form:"hint" json:"hint"`
}

// CreateApplicationJSONRequestBody defines body for CreateApplication for application/json ContentType.
type CreateApplicationJSONRequestBody = Application

// PatchApplicationJSONRequestBody defines body for PatchApplication for application/json ContentType.
type PatchApplicationJSONRequestBody = ApplicationPatch

// UpdateApplicationJSONRequestBody defines body for UpdateApplication for application/json ContentType.
type UpdateApplicationJSONRequestBody = Application

// CreateApiSecretJSONRequestBody defines body for CreateApiSecret for application/json ContentType.
type CreateApiSecretJSONRequestBody = ApiSecretData

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAllApplications request
	GetAllApplications(ctx context.Context, params *GetAllApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApplicationWithBody request with any body
	CreateApplicationWithBody(ctx context.Context, params *CreateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApplication(ctx context.Context, params *CreateApplicationParams, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApplication request
	DeleteApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApplication request
	GetApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, params *GetApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchApplicationWithBody request with any body
	PatchApplicationWithBody(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, body PatchApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApplicationWithBody request with any body
	UpdateApplicationWithBody(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiSecret request
	DeleteApiSecret(ctx context.Context, applicationIdentifier openapi_types.UUID, params *DeleteApiSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiSecrets request
	GetApiSecrets(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiSecretWithBody request with any body
	CreateApiSecretWithBody(ctx context.Context, applicationIdentifier openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiSecret(ctx context.Context, applicationIdentifier openapi_types.UUID, body CreateApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAllApplications(ctx context.Context, params *GetAllApplicationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllApplicationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplicationWithBody(ctx context.Context, params *CreateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApplication(ctx context.Context, params *CreateApplicationParams, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApplicationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApplicationRequest(c.Server, applicationIdentifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, params *GetApplicationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApplicationRequest(c.Server, applicationIdentifier, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApplicationWithBody(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApplicationRequestWithBody(c.Server, applicationIdentifier, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, body PatchApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchApplicationRequest(c.Server, applicationIdentifier, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplicationWithBody(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationRequestWithBody(c.Server, applicationIdentifier, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApplication(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApplicationRequest(c.Server, applicationIdentifier, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiSecret(ctx context.Context, applicationIdentifier openapi_types.UUID, params *DeleteApiSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiSecretRequest(c.Server, applicationIdentifier, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiSecrets(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiSecretsRequest(c.Server, applicationIdentifier)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiSecretWithBody(ctx context.Context, applicationIdentifier openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiSecretRequestWithBody(c.Server, applicationIdentifier, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiSecret(ctx context.Context, applicationIdentifier openapi_types.UUID, body CreateApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiSecretRequest(c.Server, applicationIdentifier, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAllApplicationsRequest generates requests for GetAllApplications
func NewGetAllApplicationsRequest(server string, params *GetAllApplicationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Schema != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema", runtime.ParamLocationQuery, *params.Schema); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Inherit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inherit", runtime.ParamLocationQuery, *params.Inherit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApplicationRequest calls the generic CreateApplication builder with application/json body
func NewCreateApplicationRequest(server string, params *CreateApplicationParams, body CreateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApplicationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateApplicationRequestWithBody generates requests for CreateApplication with any type of body
func NewCreateApplicationRequestWithBody(server string, params *CreateApplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ModifiedOnBehalfOf != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Modified-on-behalf-of", runtime.ParamLocationHeader, *params.ModifiedOnBehalfOf)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Modified-on-behalf-of", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApplicationRequest generates requests for DeleteApplication
func NewDeleteApplicationRequest(server string, applicationIdentifier openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApplicationRequest generates requests for GetApplication
func NewGetApplicationRequest(server string, applicationIdentifier openapi_types.UUID, params *GetApplicationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Schema != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schema", runtime.ParamLocationQuery, *params.Schema); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Inherit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "inherit", runtime.ParamLocationQuery, *params.Inherit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchApplicationRequest calls the generic PatchApplication builder with application/json body
func NewPatchApplicationRequest(server string, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, body PatchApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchApplicationRequestWithBody(server, applicationIdentifier, params, "application/json", bodyReader)
}

// NewPatchApplicationRequestWithBody generates requests for PatchApplication with any type of body
func NewPatchApplicationRequestWithBody(server string, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ModifiedOnBehalfOf != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Modified-on-behalf-of", runtime.ParamLocationHeader, *params.ModifiedOnBehalfOf)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Modified-on-behalf-of", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateApplicationRequest calls the generic UpdateApplication builder with application/json body
func NewUpdateApplicationRequest(server string, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, body UpdateApplicationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateApplicationRequestWithBody(server, applicationIdentifier, params, "application/json", bodyReader)
}

// NewUpdateApplicationRequestWithBody generates requests for UpdateApplication with any type of body
func NewUpdateApplicationRequestWithBody(server string, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.ModifiedOnBehalfOf != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Modified-on-behalf-of", runtime.ParamLocationHeader, *params.ModifiedOnBehalfOf)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Modified-on-behalf-of", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteApiSecretRequest generates requests for DeleteApiSecret
func NewDeleteApiSecretRequest(server string, applicationIdentifier openapi_types.UUID, params *DeleteApiSecretParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/apiSecrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hint", runtime.ParamLocationQuery, params.Hint); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiSecretsRequest generates requests for GetApiSecrets
func NewGetApiSecretsRequest(server string, applicationIdentifier openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/apiSecrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiSecretRequest calls the generic CreateApiSecret builder with application/json body
func NewCreateApiSecretRequest(server string, applicationIdentifier openapi_types.UUID, body CreateApiSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiSecretRequestWithBody(server, applicationIdentifier, "application/json", bodyReader)
}

// NewCreateApiSecretRequestWithBody generates requests for CreateApiSecret with any type of body
func NewCreateApiSecretRequestWithBody(server string, applicationIdentifier openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "applicationIdentifier", runtime.ParamLocationPath, applicationIdentifier)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/%s/apiSecrets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAllApplicationsWithResponse request
	GetAllApplicationsWithResponse(ctx context.Context, params *GetAllApplicationsParams, reqEditors ...RequestEditorFn) (*GetAllApplicationsResponse, error)

	// CreateApplicationWithBodyWithResponse request with any body
	CreateApplicationWithBodyWithResponse(ctx context.Context, params *CreateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error)

	CreateApplicationWithResponse(ctx context.Context, params *CreateApplicationParams, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error)

	// DeleteApplicationWithResponse request
	DeleteApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteApplicationResponse, error)

	// GetApplicationWithResponse request
	GetApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *GetApplicationParams, reqEditors ...RequestEditorFn) (*GetApplicationResponse, error)

	// PatchApplicationWithBodyWithResponse request with any body
	PatchApplicationWithBodyWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApplicationResponse, error)

	PatchApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, body PatchApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApplicationResponse, error)

	// UpdateApplicationWithBodyWithResponse request with any body
	UpdateApplicationWithBodyWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error)

	UpdateApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error)

	// DeleteApiSecretWithResponse request
	DeleteApiSecretWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *DeleteApiSecretParams, reqEditors ...RequestEditorFn) (*DeleteApiSecretResponse, error)

	// GetApiSecretsWithResponse request
	GetApiSecretsWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetApiSecretsResponse, error)

	// CreateApiSecretWithBodyWithResponse request with any body
	CreateApiSecretWithBodyWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiSecretResponse, error)

	CreateApiSecretWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, body CreateApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiSecretResponse, error)
}

type GetAllApplicationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationsResponse
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetAllApplicationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllApplicationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApplicationResponse
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r PatchApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateApplicationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateApplicationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApplicationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteApiSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiSecretsResponse
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r GetApiSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ApiSecretResponse
	JSON400      *Error
	JSON401      *Error
	JSON403      *Error
	JSON500      *Error
}

// Status returns HTTPResponse.Status
func (r CreateApiSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAllApplicationsWithResponse request returning *GetAllApplicationsResponse
func (c *ClientWithResponses) GetAllApplicationsWithResponse(ctx context.Context, params *GetAllApplicationsParams, reqEditors ...RequestEditorFn) (*GetAllApplicationsResponse, error) {
	rsp, err := c.GetAllApplications(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllApplicationsResponse(rsp)
}

// CreateApplicationWithBodyWithResponse request with arbitrary body returning *CreateApplicationResponse
func (c *ClientWithResponses) CreateApplicationWithBodyWithResponse(ctx context.Context, params *CreateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error) {
	rsp, err := c.CreateApplicationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationResponse(rsp)
}

func (c *ClientWithResponses) CreateApplicationWithResponse(ctx context.Context, params *CreateApplicationParams, body CreateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApplicationResponse, error) {
	rsp, err := c.CreateApplication(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApplicationResponse(rsp)
}

// DeleteApplicationWithResponse request returning *DeleteApplicationResponse
func (c *ClientWithResponses) DeleteApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteApplicationResponse, error) {
	rsp, err := c.DeleteApplication(ctx, applicationIdentifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApplicationResponse(rsp)
}

// GetApplicationWithResponse request returning *GetApplicationResponse
func (c *ClientWithResponses) GetApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *GetApplicationParams, reqEditors ...RequestEditorFn) (*GetApplicationResponse, error) {
	rsp, err := c.GetApplication(ctx, applicationIdentifier, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApplicationResponse(rsp)
}

// PatchApplicationWithBodyWithResponse request with arbitrary body returning *PatchApplicationResponse
func (c *ClientWithResponses) PatchApplicationWithBodyWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchApplicationResponse, error) {
	rsp, err := c.PatchApplicationWithBody(ctx, applicationIdentifier, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApplicationResponse(rsp)
}

func (c *ClientWithResponses) PatchApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *PatchApplicationParams, body PatchApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchApplicationResponse, error) {
	rsp, err := c.PatchApplication(ctx, applicationIdentifier, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchApplicationResponse(rsp)
}

// UpdateApplicationWithBodyWithResponse request with arbitrary body returning *UpdateApplicationResponse
func (c *ClientWithResponses) UpdateApplicationWithBodyWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error) {
	rsp, err := c.UpdateApplicationWithBody(ctx, applicationIdentifier, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationResponse(rsp)
}

func (c *ClientWithResponses) UpdateApplicationWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *UpdateApplicationParams, body UpdateApplicationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApplicationResponse, error) {
	rsp, err := c.UpdateApplication(ctx, applicationIdentifier, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApplicationResponse(rsp)
}

// DeleteApiSecretWithResponse request returning *DeleteApiSecretResponse
func (c *ClientWithResponses) DeleteApiSecretWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, params *DeleteApiSecretParams, reqEditors ...RequestEditorFn) (*DeleteApiSecretResponse, error) {
	rsp, err := c.DeleteApiSecret(ctx, applicationIdentifier, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiSecretResponse(rsp)
}

// GetApiSecretsWithResponse request returning *GetApiSecretsResponse
func (c *ClientWithResponses) GetApiSecretsWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetApiSecretsResponse, error) {
	rsp, err := c.GetApiSecrets(ctx, applicationIdentifier, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiSecretsResponse(rsp)
}

// CreateApiSecretWithBodyWithResponse request with arbitrary body returning *CreateApiSecretResponse
func (c *ClientWithResponses) CreateApiSecretWithBodyWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiSecretResponse, error) {
	rsp, err := c.CreateApiSecretWithBody(ctx, applicationIdentifier, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiSecretResponse(rsp)
}

func (c *ClientWithResponses) CreateApiSecretWithResponse(ctx context.Context, applicationIdentifier openapi_types.UUID, body CreateApiSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiSecretResponse, error) {
	rsp, err := c.CreateApiSecret(ctx, applicationIdentifier, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiSecretResponse(rsp)
}

// ParseGetAllApplicationsResponse parses an HTTP response from a GetAllApplicationsWithResponse call
func ParseGetAllApplicationsResponse(rsp *http.Response) (*GetAllApplicationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllApplicationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateApplicationResponse parses an HTTP response from a CreateApplicationWithResponse call
func ParseCreateApplicationResponse(rsp *http.Response) (*CreateApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteApplicationResponse parses an HTTP response from a DeleteApplicationWithResponse call
func ParseDeleteApplicationResponse(rsp *http.Response) (*DeleteApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApplicationResponse parses an HTTP response from a GetApplicationWithResponse call
func ParseGetApplicationResponse(rsp *http.Response) (*GetApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApplicationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePatchApplicationResponse parses an HTTP response from a PatchApplicationWithResponse call
func ParsePatchApplicationResponse(rsp *http.Response) (*PatchApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateApplicationResponse parses an HTTP response from a UpdateApplicationWithResponse call
func ParseUpdateApplicationResponse(rsp *http.Response) (*UpdateApplicationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateApplicationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteApiSecretResponse parses an HTTP response from a DeleteApiSecretWithResponse call
func ParseDeleteApiSecretResponse(rsp *http.Response) (*DeleteApiSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetApiSecretsResponse parses an HTTP response from a GetApiSecretsWithResponse call
func ParseGetApiSecretsResponse(rsp *http.Response) (*GetApiSecretsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiSecretsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateApiSecretResponse parses an HTTP response from a CreateApiSecretWithResponse call
func ParseCreateApiSecretResponse(rsp *http.Response) (*CreateApiSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ApiSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
